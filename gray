#!/usr/bin/env ruby

class Token
  attr_reader :type, :text

  def initialize type, text = ''
    @type = type
    @text = text
  end
end

class Lexer
  attr_reader :tokens, :src

  def initialize src
    @src = src.dup
  end

  def lex
    @state = :linestart
    @tokens = []
    @i = 0

    token = nil
    until token && token.type == :EOF
      token = get_token
      # puts "#{@state.inspect} #{token.inspect}"
      @tokens << token
    end
  end

  def get_token
    @token_so_far = ''

    if @i >= src.length
      Token.new :EOF
    elsif @state == :linestart
      get_linestart_token
    elsif @state == :default
      get_default_token
    elsif @state == :blockcode
      get_block_code_token
    elsif @state == :command
      get_command
    elsif @state == :attributes
      get_attributes
    elsif @state == :style_name
      get_style_name
    elsif @state == :inline_code
      get_token_after_backtick
    elsif @state == :style_lines
      get_style_lines
    elsif @state == :eatspace
      until @i >= src.length || @src[@i] != ' '
        @i += 1
      end
      @state = :default
      get_token
    end
  end

  def get_command
    rest = @src[@i..-1]
    if rest =~ /\Astyle/
      @i += $&.length
      while @src[@i] == ' '
        @i += 1
      end
      @state = :style_name
      Token.new :STYLE, $&
    elsif @src[@i] =~ /[A-Za-z0-9]/
      while @i < @src.length && @src[@i] =~ /[A-Za-z0-9]/
        @token_so_far << @src[@i]
        @i += 1
      end
      @id = @token_so_far
      @state = :attributes
      Token.new :IDENTIFIER, @token_so_far
    elsif @src[@i] == '"'
      # Skip over ".
      @i += 1

      # Skip over whitespace.
      while @i < @src.length && @src[@i] =~ /[ \t]/
        @i += 1
      end

      @token_so_far = ''
      while @i < @src.length && @src[@i] != ']'
        @token_so_far << @src[@i]
        @i += 1
      end

      @state = :default
      Token.new :COMMENT, @token_so_far
    else
      raise "I dunno #{@src[@i..-1]}"
    end
  end

  def get_style_name
    # rest = @src[@i..-1]
    # puts rest

    @token_so_far = ''
    while @i < @src.length && @src[@i] =~ /\w|\.|\d/
      @token_so_far << @src[@i]
      @i += 1
    end

    if @src[@i] == "\n"
      @i += 1
    else
      raise "ouch"
    end

    @state = :style_lines
    Token.new :IDENTIFIER, @token_so_far
  end

  def get_style_lines
    if @src[@i] == ']'
      @i += 1
      @state = :default
      Token.new :RIGHT_BRACKET, ']'
    else
      @token_so_far = ''
      while @i < @src.length && @src[@i] != "\n"
        @token_so_far << @src[@i]
        @i += 1
      end

      if @src[@i] == "\n"
        @i += 1
      else
        raise "ouch2"
      end

      Token.new :STYLE_LINE, @token_so_far
    end
  end

  def get_attributes
    while @src[@i] == ' '
      @i += 1
    end

    if @src[@i] == "\n"
      if @id == 'code' || @id == 'lineveil' || @id == 'madeup'
        @state = :blockcode
      elsif @id == 'block'
        @state = :linestart
      else
        @state = :default
      end
      @i += 1
      Token.new :EOL, "\n"
    elsif @src[@i] == ']'
      @i += 1
      @state = :default
      Token.new :RIGHT_BRACKET, ']'
    elsif @src[@i] == '='
      @i += 1
      Token.new :EQUALS, '='
    elsif @src[@i] == '"'
      @i += 1
      value = ''
      while @i < @src.length && @src[@i] != '"'
        @token_so_far << @src[@i]
        @i += 1
      end
      if @src[@i] == '"'
        @i += 1
      end
      Token.new :QUOTED_VALUE, @token_so_far
    elsif @src[@i] !~ /[= \]\n]/
      while @i < @src.length && @src[@i] !~ /[= \]\n]/
        @token_so_far << @src[@i]
        @i += 1
      end
      if @token_so_far =~ /^[A-Za-z][A-Za-z0-9]+$/
        Token.new :IDENTIFIER, @token_so_far
      else
        Token.new :UNQUOTED_VALUE, @token_so_far
      end
    end
  end

  def get_linestart_token
    rest = @src[@i..-1]

    if rest =~ /\A(\d+)\.\s+/
      @i += $&.length
      @state = :default
      Token.new :INT, @token_so_far
    elsif rest =~ /\A-{5,}\r?\n/
      @i += $&.length
      Token.new :LINE, @token_so_far
    else
      c = src[@i]
      @i += 1
      @token_so_far << c

      case c
        when ' '
          get_token_indent
        when '-'
          @state = :eatspace
          Token.new :BULLET, @token_so_far
        when '#'
          get_token_after_hash
        else
          @i -= 1
          @token_so_far = ''
          @state = :default
          get_default_token
      end
    end
  end

  def get_token_after_hash
    while @i < @src.length && @src[@i] == '#'
      @token_so_far << @src[@i]
      @i += 1
    end
    @state = :eatspace
    Token.new :HASHES, @token_so_far
  end

  def get_default_token
    c = src[@i]
    @i += 1
    @token_so_far << c

    case c
      when "\n"
        @state = :linestart
        Token.new :EOL, @token_so_far
      when '*'
        get_token_after_asterisk
      when '`'
        @state = :inline_code
        Token.new :BACKTICK, @token_so_far
      when '['
        @state = :command
        Token.new :LEFT_BRACKET, @token_so_far
      when ']'
        Token.new :RIGHT_BRACKET, @token_so_far
      when '-'
        get_token_after_dash
      else
        get_token_content
    end
  end

  def get_token_after_backtick
    c = src[@i]
    @i += 1
    @token_so_far << c

    if c == '`'
      @state = :default
      Token.new :BACKTICK, @token_so_far
    else
      while @i < @src.length && @src[@i] != '`'
        @token_so_far << @src[@i]
        @i += 1
      end
      Token.new :CODE, @token_so_far
    end
  end

  def get_token_after_dash
    if @i + 1 < @src.length && @src[@i] == '-' && @src[@i + 1] == '-'
      @i += 2
      Token.new :EMDASH, '---'
    else
      get_token_content
    end
  end

  def get_token_after_asterisk
    if @i < @src.length && @src[@i] == '*'
      @i += 1
      Token.new :STARSTAR, @token_so_far
    else
      Token.new :STAR, @token_so_far
    end
  end

  def get_block_code_token
    if @src[@i..-1] =~ /\A([ \t]*\])/
      @i += $1.length
      @state = :default
      Token.new :RIGHT_BRACKET, ']'
    elsif @src[@i] == "\n"
      @i += 1
      Token.new :EOL, "\n"
    else
      while @i < @src.length && @src[@i] != "\n"
        @token_so_far << @src[@i]
        @i += 1
      end
      Token.new :CODE, @token_so_far
    end
  end

  def get_token_content
    while @i < @src.length && @src[@i] != "\n" && @src[@i] != '`' && @src[@i] != '*' && @src[@i] != '[' && @src[@i] != '-'
      @token_so_far << @src[@i]
      @i += 1
    end
    Token.new :CONTENT, @token_so_far
  end

  def get_token_indent
    while @i < @src.length && @src[@i] == ' '
      @token_so_far << @src[@i]
      @i += 1
    end
    Token.new :INDENT, @token_so_far
  end
end

class Parser
  def initialize tokens, target
    @tokens = tokens
    @target = target
    @root = nil
    @styles = Hash.new

    @tokens.each do |token|
      if token.type == :COMMENT
        if token.text =~ /\broot\s*=\s*(\S+)/
          @root = $1
        end
      end
    end

    if @target == 'wordpress'
      @root = Dir.pwd.gsub!(/^.*\/writing/, '/gray/writing')
    end
    
    # puts @root
  end

  def entitize code
    code.gsub(/&/, '&amp;').gsub(/</, '&lt;').gsub(/>/, '&gt;')
  end

  def parse
    dst = ''
    if @target == 'html'
      dst += <<EOF
<!doctype html>
<head>
  <title>Foo</title>
  <style>

body {
  width: 600px;
  font-family: Arial;
}
  
  </style>
  <script language="JavaScript">

function autosize(id) {
  var element = document.getElementById(id);
  element.width = element.contentWindow.document.body.scrollWidth;
  element.height = element.contentWindow.document.body.scrollHeight;
}

  </script>
</head>
<body>
EOF
    end

    @is_in_backtick = false
    @is_in_asterisk = false
    @is_in_starstar = false

    @i = 0
    until @tokens[@i].type == :EOF
      dst += line
    end

    if @target == 'html'
      dst += "</body>\n</html>\n"
    end

    dst
  end

  def list indent
    dst = ''

    if indent == 0
      list_type = @tokens[@i].type
    else
      list_type = @tokens[@i + 1].type
    end

    dst += "#{' ' * 2 * indent}<#{list_type == :BULLET ? 'u' : 'o'}l>\n"
    while (indent == 0 && @tokens[@i].type == list_type) || (@tokens[@i].type == :INDENT && @tokens[@i].text.length / 2 == indent && @tokens[@i + 1].type == list_type)
      if @tokens[@i].type == :INDENT
        @i += 1
      end
      @i += 1
      dst += "#{' ' * 2 * (indent + 1)}<li>"
      dst += content
      if @tokens[@i].type == :EOL
        @i += 1
      else
        raise 'expected eol'
      end
      if @i + 1 < @tokens.length && @tokens[@i].type == :INDENT && @tokens[@i].text.length / 2 > indent && (@tokens[@i + 1].type == :BULLET || @tokens[@i + 1].type == :INT)
        dst += "\n"
        puts @tokens[@i].text.length / 2
        puts indent
        puts @tokens[@i].inspect
        puts @tokens[@i + 1].inspect
        dst += list indent + 1
        dst += ' ' * 2 * indent
      end
      dst += "</li>\n"
    end
    dst += "#{' ' * 2 * indent}</#{list_type == :BULLET ? 'u' : 'o'}l>\n"

    dst
  end

  def line
    dst = ''

    if @tokens[@i].type == :HASHES
      rank = @tokens[@i].text.length
      rank += 2 if @target == 'wordpress'
      dst += "<h#{rank}>"
      @i += 1
      dst += content
      dst += "</h#{rank}>\n"
      if @tokens[@i].type == :EOL
        @i += 1
      else
        raise "Expected end-of-line, found #{@tokens[@i].type}"
      end
    elsif @tokens[@i].type == :LINE
      if @styles.has_key? 'gray.line'
        dst += "<hr style=\"#{@styles['gray.line']}\">"
      else
        dst += '<hr>'
      end
      @i += 1
    elsif @tokens[@i].type == :INDENT
      @i += 1
    elsif @tokens[@i].type == :BULLET
      dst += list 0
    elsif @tokens[@i].type == :INT
      dst += list 0
    else
      dst += content
      # TODO not if only comment
      dst += "\n"
      if @tokens[@i].type == :EOL
        @i += 1
      else
        raise "Expected end-of-line, found #{@tokens[@i].type}"
      end
    end

    dst
  end

  def first_of_content? type
    ([:CONTENT, :LEFT_BRACKET, :COMMENT].member? type) || (type == :BACKTICK && !@is_in_backtick) || (type == :STAR && !@is_in_asterisk) || (type == :STARSTAR && !@is_in_starstar) || (type == :EMDASH)
  end

  def first_of_line? type
    ([:HASHES, :LINE, :INDENT, :BULLET, :INT, :EOL].member? type) || first_of_content?(type)
  end

  def parse_attributes
    attributes = Hash.new
    while @tokens[@i].type == :IDENTIFIER
      key = @tokens[@i].text
      @i += 1
      if @tokens[@i].type == :EQUALS
        @i += 1
      else
        raise "expected =, found #{@tokens[@i].type}"
      end
      if @tokens[@i].type == :QUOTED_VALUE || @tokens[@i].type == :UNQUOTED_VALUE || @tokens[@i].type == :IDENTIFIER
        value = @tokens[@i].text
        @i += 1
      else
        raise "expected =, found #{@tokens[@i].type}"
      end
      attributes[key] = value
    end
    attributes
  end

  def count_preceding_linebreaks
    n = 0
    pi = @i - 1
    while pi >= 0
      # puts @tokens[pi].inspect
      if @tokens[pi].type == :EOL
        n += 1
        # puts n
        pi -= 1
      elsif pi >= 2 && @tokens[pi - 2].type == :LEFT_BRACKET && @tokens[pi - 1].type == :COMMENT && @tokens[pi].type == :RIGHT_BRACKET
        pi -= 3
      else
        break
      end
    end
    # puts
    n
  end

  def is_comment
    @tokens[@i].type == :LEFT_BRACKET && @tokens[@i + 1].type == :COMMENT && @tokens[@i + 2].type == :RIGHT_BRACKET
  end

  def is_block
    @tokens[@i].type == :LEFT_BRACKET && @tokens[@i + 1].type == :IDENTIFIER && @tokens[@i + 1].text == 'block'
  end

  def content
    dst = ''

    # Need a paragraph?
    # puts "checking before #{@tokens[@i].inspect}"
    needs_paragraph = count_preceding_linebreaks >= 2 && !is_comment && !is_block && @tokens[@i].type != :EOL # @i - 2 >= 0 && @tokens[@i - 2].type == :EOL && @tokens[@i - 1].type == :EOL
    # puts needs_paragraph
    dst += "<p>" if needs_paragraph

    while first_of_content? @tokens[@i].type
      if @tokens[@i].type == :CONTENT
        dst += @tokens[@i].text
        @i += 1
      elsif @tokens[@i].type == :BACKTICK
        @i += 1
        dst += '<code>'
        @is_in_backtick = true
        if @tokens[@i].type != :CODE
          raise "expected backtick, found #{@tokens[@i].inspect}"
        end
        dst += entitize(@tokens[@i].text)
        @i += 1
        if @tokens[@i].type == :BACKTICK
          @i += 1
        else
          raise "expected backtick, found #{@tokens[@i].inspect}"
        end
        @is_in_backtick = false
        dst += '</code>'
      elsif @tokens[@i].type == :STAR
        @i += 1
        dst += '<em>'
        @is_in_asterisk = true
        dst += content
        if @tokens[@i].type == :STAR
          @i += 1
        else
          raise "expected asterisk, found #{@tokens[@i].inspect}"
        end
        @is_in_asterisk = false
        dst += '</em>'
      elsif @tokens[@i].type == :EMDASH
        @i += 1
        dst += '&mdash;'
      elsif @tokens[@i].type == :STARSTAR
        @i += 1
        dst += '<b>'
        @is_in_starstar = true
        dst += content
        if @tokens[@i].type == :STARSTAR
          @i += 1
        else
          raise "expected starstar, found #{@tokens[@i].inspect}"
        end
        @is_in_starstar = false
        dst += '</b>'
      elsif @tokens[@i].type == :LEFT_BRACKET
        @i += 1

        if @tokens[@i].type == :COMMENT
          dst += "<!-- #{@tokens[@i].text} -->" if @target != 'wordpress'
          @i += 1
        elsif @tokens[@i].type == :STYLE
          @i += 1
          if @tokens[@i].type == :IDENTIFIER
            key = @tokens[@i].text
            @i += 1
          else
            raise "wanted ID"
          end

          lines = []
          while @tokens[@i].type == :STYLE_LINE
            lines << @tokens[@i].text
            @i += 1
          end 

          @styles[key] = lines.map { |line| "#{line};" }.join(' ')
        elsif @tokens[@i].type == :IDENTIFIER
          command = @tokens[@i].text
          @i += 1
          attributes = parse_attributes

          # Expand style key.
          if attributes.has_key? 'style'
            attributes['style'] = @styles[attributes['style']]
          end

          if command == "link"
            dst += "<a href=\"#{attributes['to']}\">#{attributes['title']}</a>"
            
          elsif command == "frame"
            s = attributes.map { |key, value| ['src', 'autosize'].member?(key) ? '' : " #{key}=\"#{value}\"" }.join
            if attributes.has_key?('autosize') && attributes['autosize'] == 'true' && attributes.has_key?('id')
              if @target == 'wordpress'
                autosize_attribute = " autosize=\"true\""
              else
                autosize_attribute = " onload=\"autosize('#{attributes['id']}')\"";
              end
            else
              autosize_attribute = ""
            end
            if @target == 'wordpress'
              src = attributes['src']
              if src !~ /https?:\/\// && @root
                src = "#{@root}/#{src}"
              end
              dst += "[frame src=\"#{src}\"#{s}#{autosize_attribute}]"
            else
              dst += "<iframe src=\"#{attributes['src']}\"#{s}#{autosize_attribute}></iframe>"
            end

          elsif command == "youtube"
            attributes['src'].gsub!(/youtu\.be/, 'www.youtube.com/embed')
            s = attributes.map { |key, value| key == 'src' ? '' : " #{key}=\"#{value}\"" }.join
            if @target == 'wordpress'
              dst += "[frame src=\"#{attributes['src']}\"#{s} frameborder=\"0\" allowfullscreen]"
            else
              dst += "<iframe src=\"#{attributes['src']}\"#{s} frameborder=\"0\" allowfullscreen></iframe>"
            end
          elsif command == "image"
            s = attributes.map { |key, value| (key == 'src' || key == 'selflink') ? '' : " #{key}=\"#{value}\"" }.join
            # TODO, if src is not relative, don't prefix it
            is_selflink = attributes.has_key? 'selflink' && attributes['selflink']
            if is_selflink
              dst += "<a href=\"#{@root}/#{attributes['src']}\">"
            end
            dst += "<img src=\"#{@root}/#{attributes['src']}\"#{s}>"
            if is_selflink
              dst += "</a>"
            end
          else
            pair_string = attributes.map { |key, value| " #{key}=\"#{value}\"" }.join

            if command != 'code' || !attributes.has_key?('file')
              if @tokens[@i].type == :EOL
                @i += 1
              else
                raise "expected EOL, found #{@tokens[@i].type}"
              end
            end

            if command == 'code'
              code = ''
              if attributes.has_key? 'file'
                code = IO.read(attributes['file'])
              else
                while @i < @tokens.length && (@tokens[@i].type == :CODE || @tokens[@i].type == :EOL)
                  if @tokens[@i].type == :CODE
                    if @i + 2 < @tokens.length && @tokens[@i + 2].type == :CODE
                      code += "#{@tokens[@i].text}\n"
                    else
                      code += @tokens[@i].text
                    end
                    @i += 1
                  else
                    code += "\n\n"
                  end
                  if @tokens[@i].type == :EOL
                    @i += 1
                  else
                    raise "expected EOL after code, found #{@tokens[@i].type}"
                  end
                end
              end
              if attributes.has_key? 'lang'
                IO.popen("coderay -#{attributes['lang']} -div", 'r+') do |pipe|
                  pipe.puts code
                  pipe.close_write
                  code = pipe.read
                  dst += code
                end
              else
                dst += "<pre#{pair_string}>"
                dst += entitize(code)
                dst += '</pre>'
              end
            elsif command == 'lineveil'
              dst += "<pre#{pair_string}>"
              li = 0
              while @i < @tokens.length && @tokens[@i].type == :CODE
                dst += "<a href=\"#\" class=\"lineveil\">#{li}</a>: <span class=\"lineveil\">#{@tokens[@i].text}</span>"
                if @i + 2 < @tokens.length && @tokens[@i + 2].type == :CODE
                  dst += "\n"
                end
                @i += 1
                if @tokens[@i].type == :EOL
                  @i += 1
                else
                  raise "expected EOL after code, found #{@tokens[@i].type}"
                end
                li += 1
              end
              dst += '</pre>'
            elsif command == 'madeup'
              ['id', 'weight', 'height'].each do |key|
                if !attributes.has_key? key
                  raise "madeup snippet must have #{key} attribute!"
                end
              end

              code = ''
              while @i < @tokens.length && @tokens[@i].type == :CODE
                code += @tokens[@i].text
                if @i + 2 < @tokens.length && @tokens[@i + 2].type == :CODE
                  code += "\n"
                end
                @i += 1
                if @tokens[@i].type == :EOL
                  @i += 1
                else
                  raise "expected EOL after code, found #{@tokens[@i].type}"
                end
              end

              if @target == 'wordpress'
                dst += <<EOF
<pre>[mup id=#{attributes['id']} width=#{attributes['width']} height=#{attributes['height']}]#{code}[/mup]</pre>
EOF
              else
                dst += <<EOF
<div id="mup_#{attributes['id']}">
  <form style="display: none" id="mup_form_#{attributes['id']}" target="mup_frame_#{attributes['id']}" action="http://embed.madeup.xyz:9013" method="post">
    <textarea name="src">#{code}</textarea>
    <input type="submit"/>
  </form>
  <iframe name=\"mup_frame_#{attributes['id']}\" src=\"\" width=\"#{attributes['width']}\" height=\"#{attributes['height']}\"></iframe>
  <script>                                                                                                                                                                        
    document.getElementById('mup_form_#{attributes['id']}').submit();
  </script>
</div>
EOF
              end

            elsif command == 'quote'
              dst += "<blockquote#{pair_string}>"
              while @i < @tokens.length && (first_of_content? @tokens[@i].type)
                dst += content
                dst += "\n" if @i + 1 < @tokens.length && @tokens[@i + 1].type != :RIGHT_BRACKET
                if @tokens[@i].type == :EOL
                  @i += 1
                else
                  raise "expected EOL after quote content, found #{@tokens[@i].type}"
                end
              end
              dst += '</blockquote>'
            elsif command == 'block'
              dst += "<div#{pair_string}>\n"
              while @i < @tokens.length && (first_of_line? @tokens[@i].type)
                dst += line
              end
              dst += '</div>'
            elsif command == 'toggle'
              dst += "<div class=\"toggle\"#{pair_string}>"
              while @i < @tokens.length && (first_of_content? @tokens[@i].type)
                dst += content
                dst += "\n" if @i + 1 < @tokens.length && @tokens[@i + 1].type != :RIGHT_BRACKET
                if @tokens[@i].type == :EOL
                  @i += 1
                else
                  raise "expected EOL after toggle content, found #{@tokens[@i].type}"
                end
              end
              dst += '</div>'
            end
          end
        else
          raise 'expected ID'
        end

        if @tokens[@i].type == :RIGHT_BRACKET
          @i += 1
        else
          puts dst
          raise "expected ], found #{@tokens[@i].inspect}"
        end
      end
    end

    dst += "</p>" if needs_paragraph

    dst
  end
end

# TODO
# comments - check
# linebreaks - check
# nesting - check
# attributes - check
# unordered lists - check
# ordered lists - check
# bold text - check
# nested lists - check
# links - check
# images - check
# coderay - check
# toggle - check
# lineveil - check
# madeup iframe - check
# general iframe - check

# src = <<EOF
# [lineveil
# a
# b
# c
# d
# ]

# [frame src=http://www.twodee.org width=600 height=200]

# [madeup width=600 height=400 id=square
# moveto 0, 0, 0
# repeat 4
  # move 10
  # yaw 90
# end
# dowel
# ]
# EOF

# src = <<EOF
# - [toggle
# [code
# this quick brown fox
# ]
# ]
# - [toggle
# that quick brown fox
# ]
# - [toggle
# there quick brown fox
# ]
# EOF

# src = <<'EOF'
# - [code
# line 1
# ]
# - [code 
# line 2
# ]

# [code lang=madeup
# moveto 0, 0, 0
# repeat 4
  # move 10
  # yaw 90
# end
# ]

# [code lang=c
# int main(int argc, char **argv) {
  # printf("%d\n", argc);
# }
# ]
# EOF

# src = <<EOF
# - a
# - b
  # 1. **zoo**
    # - the
    # - inner
    # - inner
    # - list
  # 2. *2*
  # 3. `some program code`
# - c

# asdfasd [link to="http://www.madeup.xyz" title="Zig Zog"]
# [image src=foo.png width=20 height=40]
# EOF

# src = <<EOF
# 1. foo0
# 2. foo1
# 3. foo2
# 4. foo3

# Hi
## There
### Agenda
#### Four
##### Five
###### Six

# - dog
# - cat
# - whistle

# foo `*code*` is a winner
# [" this is a comment]

# [code lang=ruby
# puts 10
# ]

# [block id=foo7 width=20
# 123
# [block
# inside block
# ]
# ]
# EOF

src = File.read(ARGV[1])
lexer = Lexer.new src
lexer.lex
parser = Parser.new lexer.tokens, ARGV[0]
puts parser.parse
