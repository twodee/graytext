#!/usr/bin/env ruby

$config = Hash.new

command = ARGV.shift

def configure path
  dir = File.expand_path(path)
  $offset = ''
  loop do
    dir = File.dirname(dir)
    rc_file = dir + '/.grayrc'
    if File.exists?(rc_file)
      lines = IO.read(rc_file).lines.grep(/(.*?)\s*=\s*(.*?)/)
      $config = lines.map { |line| line.chomp.split(/\s*=\s*/) }.to_h
      break
    end
    break if dir == '/'
    $offset = File.basename(dir) + '/' + $offset
  end

  $offset.gsub!(/\/$/, '')
end

if command == 'upload'
  ARGV.each do |path|
    configure path

    dir = "/var/www/twodee/#{$config['root']}/#{$offset}".gsub(/\/{2,}/, '/')

    command = "ssh twodee 'mkdir -p #{dir} && umask 0017 && chmod -R g+X /var/www/twodee/#{$config['root']}/#{$offset.gsub(/\/.*$/, '')}' && scp #{path} twodee:#{dir} && ssh twodee 'chmod g+r #{dir}/#{File.basename(path)}'"
    puts command
    `#{command}`

    puts
  end

  exit 0
elsif command == 'code'
  path = ARGV.shift 
  code = ''
  ARGV.each_with_index do |codepath, i|
    if i > 0
      code += "\n"
    end
    code += "## #{File.basename(codepath)}\n\n"
    language = case File.extname(codepath)
      when '.java'
        'java'
      when '.mup'
        'madeup'
      when '.cpp', '.h', '.ino'
        'cpp'
      when '.c'
        'c'
      when '.rb'
        'ruby'
      when '.zsh'
        'zsh'
      else
        ''
      end
    language = " lang=#{language}" if !language.empty?
    code += "[code#{language}\n"
    code += IO.read(codepath).gsub(/\t/, '  ').chomp
    code += "\n]\n"
  end

  text = IO.read(path)
  if !text.gsub!(/(?<=\[" CODE START\]\n).*?(?=\n\[" CODE END\])/m, code)
    text.sub!(/\s*\Z/, "\n\n[\" CODE START]\n#{code}\n[\" CODE END]\n")
  end

  File.open(path, 'w') do |file|
    file.write(text)
  end

  exit 0

end

target = ARGV[0]
path = ARGV[1]
configure path

class Token
  attr_reader :type, :text

  def initialize type, text = ''
    @type = type
    @text = text
  end
end

class Lexer
  attr_reader :tokens, :src

  def initialize src
    @src = src.dup
  end

  def lex
    @states = [:default, :linestart]
    @tokens = []
    @i = 0

    token = nil
    until token && token.type == :EOF
      token = get_token
      STDERR.puts "#{token.inspect} -- now in #{@states[-1]}"
      @tokens << token
    end
  end

  def get_token
    @token_so_far = ''

    if @i >= src.length
      Token.new :EOF
    elsif @states[-1] == :linestart
      get_linestart_token
    elsif @states[-1] == :default
      get_default_token
    elsif @states[-1] == :table
      get_table_token
    elsif @states[-1] == :blockcode
      get_block_code_token
    elsif @states[-1] == :command
      get_command
    elsif @states[-1] == :attributes
      get_attributes
    elsif @states[-1] == :style_name
      get_style_name
    elsif @states[-1] == :inline_code
      get_token_after_backtick
    elsif @states[-1] == :style_lines
      get_style_lines
    elsif @states[-1] == :eatspace
      until @i >= src.length || @src[@i] != ' '
        @i += 1
      end
      @states.pop
      get_token
    end
  end

  def get_command
    rest = @src[@i..-1]
    if rest =~ /\Astyle/
      @i += $&.length
      while @src[@i] == ' '
        @i += 1
      end
      @states[-1] = :style_name
      Token.new :STYLE, $&
    elsif @src[@i] =~ /[A-Za-z0-9]/
      while @i < @src.length && @src[@i] =~ /[A-Za-z0-9]/
        @token_so_far << @src[@i]
        @i += 1
      end
      @id = @token_so_far
      @states[-1] = :attributes
      Token.new :IDENTIFIER, @token_so_far
    elsif @src[@i] == '"'
      # Skip over ".
      @i += 1

      # Skip over whitespace.
      while @i < @src.length && @src[@i] =~ /[ \t]/
        @i += 1
      end

      @token_so_far = ''
      while @i < @src.length && @src[@i] != ']'
        @token_so_far << @src[@i]
        @i += 1
      end

      @states[-1] = :default
      Token.new :COMMENT, @token_so_far
    else
      raise "I dunno #{@src[@i..-1]}"
    end
  end

  def get_style_name
    # rest = @src[@i..-1]
    # puts rest

    @token_so_far = ''
    while @i < @src.length && @src[@i] =~ /\w|\.|\d/
      @token_so_far << @src[@i]
      @i += 1
    end

    if @src[@i] == "\n"
      @i += 1
    else
      raise "ouch"
    end

    @states[-1] = :style_lines
    Token.new :IDENTIFIER, @token_so_far
  end

  def get_style_lines
    if @src[@i] == ']'
      @i += 1
      @states[-1] = :default
      Token.new :RIGHT_BRACKET, ']'
    else
      @token_so_far = ''
      while @i < @src.length && @src[@i] != "\n"
        @token_so_far << @src[@i]
        @i += 1
      end

      if @src[@i] == "\n"
        @i += 1
      else
        raise "ouch2"
      end

      Token.new :STYLE_LINE, @token_so_far
    end
  end

  def get_attributes
    while @src[@i] == ' '
      @i += 1
    end

    if @src[@i] == "\n"
      if @id == 'code' || @id == 'lineveil' || @id == 'madeup' || @id == 'latex' # Any code blocks
        @states[-1] = :blockcode
      elsif @id == 'block' || @id == 'listveil'
        @states[-1] = :linestart
      elsif @id == 'table'
        @states[-1] = :table
      else
        @states[-1] = :default
      end
      @i += 1
      Token.new :EOL, "\n"
    elsif @src[@i] == '|'
      @i += 1
      @states[-1] = :command
      @states.push :eatspace
      Token.new :SEPARATOR, '|'
    elsif @src[@i] == ']'
      @i += 1
      @states[-1] = :default
      Token.new :RIGHT_BRACKET, ']'
    elsif @src[@i] == '='
      @i += 1
      Token.new :EQUALS, '='
    elsif @src[@i] == '"'
      @i += 1
      value = ''
      while @i < @src.length && @src[@i] != '"'
        # Allow escaped.
        if @i < @src.length - 1 && @src[@i] == '\\'
          @i += 1
        end
        @token_so_far << @src[@i]
        @i += 1
      end
      if @src[@i] == '"'
        @i += 1
      end
      Token.new :QUOTED_VALUE, @token_so_far
    elsif @src[@i] !~ /[= \]\n]/
      while @i < @src.length && @src[@i] !~ /[= \]\n]/
        @token_so_far << @src[@i]
        @i += 1
      end
      if @token_so_far =~ /^[A-Za-z][A-Za-z0-9]+$/
        Token.new :IDENTIFIER, @token_so_far
      else
        Token.new :UNQUOTED_VALUE, @token_so_far
      end
    end
  end

  def get_linestart_token
    rest = @src[@i..-1]

    if rest =~ /\A(\d+)\.\s+/
      @i += $&.length
      @states.pop
      Token.new :INT, @token_so_far
    elsif rest =~ /\A-{5,}\r?\n/
      @i += $&.length
      Token.new :LINE, @token_so_far
    else
      c = src[@i]
      @i += 1
      @token_so_far << c

      case c
        when ' '
          get_token_indent
        when '-'
          @states[-1] = :eatspace
          Token.new :BULLET, @token_so_far
        when '#'
          get_token_after_hash
        else
          @i -= 1
          @token_so_far = ''
          @states.pop
          @states.push :default
          get_default_token
      end
    end
  end

  def get_table_token
    get_default_token
  end

  def get_token_after_hash
    while @i < @src.length && @src[@i] == '#'
      @token_so_far << @src[@i]
      @i += 1
    end

    @states.push :default
    @states.push :eatspace

    if @i < @src.length && @src[@i] == '.'
      @i += 1
      Token.new :COUNTED_HASHES, @token_so_far
    else
      Token.new :HASHES, @token_so_far
    end
  end

  def get_default_token
    c = src[@i]
    @i += 1
    @token_so_far << c

    case c
      when "\n"
        if @states[-1] != :table
          @states.push :linestart
        end
        Token.new :EOL, @token_so_far
      when '*'
        get_token_after_asterisk
      when '`'
        @states.push :inline_code
        Token.new :BACKTICK, @token_so_far
      when '['
        @states.push :command
        Token.new :LEFT_BRACKET, @token_so_far
      when ']'
        @states.pop
        Token.new :RIGHT_BRACKET, @token_so_far
      when '-'
        get_token_after_dash
      when '\\'
        get_token_after_backslash
      when '|'
        if @states[-1] == :table
          Token.new :SEPARATOR, @token_so_far 
        else
          get_token_content
        end
      else
        get_token_content
    end
  end

  def get_token_after_backslash
    # Replace the slash we just read with the succeeding character.
    if @i < @src.length
      @token_so_far[-1] = src[@i]
      @i += 1
    end
    get_default_token
  end

  def get_token_after_backtick
    c = src[@i]
    @i += 1
    @token_so_far << c

    if c == '`'
      @states.pop
      Token.new :BACKTICK, @token_so_far
    else
      while @i < @src.length && @src[@i] != '`'
        @token_so_far << @src[@i]
        @i += 1
      end
      Token.new :CODE, @token_so_far
    end
  end

  def get_token_after_dash
    if @i + 1 < @src.length && @src[@i] == '-' && @src[@i + 1] == '-'
      @i += 2
      Token.new :EMDASH, '---'
    else
      get_token_content
    end
  end

  def get_token_after_asterisk
    if @i < @src.length && @src[@i] == '*'
      @i += 1
      Token.new :STARSTAR, @token_so_far
    else
      Token.new :STAR, @token_so_far
    end
  end

  def get_block_code_token
    if @src[@i..-1] =~ /\A([ \t]*\])/
      @i += $1.length
      @states.pop
      Token.new :RIGHT_BRACKET, ']'
    elsif @src[@i] == "\n"
      @i += 1
      Token.new :EOL, "\n"
    else
      while @i < @src.length && @src[@i] != "\n"
        @token_so_far << @src[@i]
        @i += 1
      end
      Token.new :CODE, @token_so_far.gsub(/\A\\\]/, ']')
    end
  end

  def get_token_content
    while @i < @src.length && @src[@i] != "\n" && @src[@i] != '`' && @src[@i] != '*' && @src[@i] != '[' && @src[@i] != '-' && (@states[-1] != :table || @src[@i] != '|')
      # Skip
      if @src[@i] == '\\' && @i + 1 < @src.length
        @i += 1
      end
      @token_so_far << @src[@i]
      @i += 1
    end
    Token.new :CONTENT, @token_so_far
  end

  def get_token_indent
    while @i < @src.length && @src[@i] == ' '
      @token_so_far << @src[@i]
      @i += 1
    end
    Token.new :INDENT, @token_so_far
  end
end

class Parser
  def initialize tokens, target
    @tokens = tokens
    @target = target
    @root = nil
    @styles = Hash.new
    @counters = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

    @tokens.each do |token|
      if token.type == :COMMENT
        if token.text =~ /\broot\s*=\s*(\S+)/
          @root = $1
        end
      end
    end

    if @target == 'wordpress'
      @root = $config['root'] + '/' + $offset
    end
    
    # STDERR.puts @root
  end

  def entitize code
    code.gsub(/&/, '&amp;').gsub(/</, '&lt;').gsub(/>/, '&gt;')
  end

  def parse
    dst = ''
    if @target == 'html'
      header = IO.read(File.dirname(__FILE__) + '/bubbles_header.html')
      # Header has \0 in it, which is special to gsub.
      header.gsub!(/(?<=<style>)(?=<\/style>)/, IO.read(File.dirname(__FILE__) + '/style.css').gsub(/(\\\d)/, '\\\\\1'))
      # STDERR.puts header
      utilities_source = IO.read(File.dirname(__FILE__) + '/utilities.js').gsub(/\\'/, "\\\\\\\\'")
      header.gsub!(/(?<=<script>)(?=<\/script>)/, utilities_source)
      dst += header
    end

    @is_in_backtick = false
    @is_in_asterisk = false
    @is_in_starstar = false

    @i = 0
    until @tokens[@i].type == :EOF
      dst += line
    end

    if @target == 'html'
      dst += IO.read(File.dirname(__FILE__) + '/bubbles_footer.html')
    end

    dst
  end

  def list indent
    dst = ''

    if indent == 0
      list_type = @tokens[@i].type
    else
      list_type = @tokens[@i + 1].type
    end

    dst += "#{' ' * 2 * indent}<#{list_type == :BULLET ? 'u' : 'o'}l>\n"
    while (indent == 0 && @tokens[@i].type == list_type) || (@tokens[@i].type == :INDENT && @tokens[@i].text.length / 2 == indent && @tokens[@i + 1].type == list_type)
      if @tokens[@i].type == :INDENT
        @i += 1
      end
      @i += 1
      dst += "#{' ' * 2 * (indent + 1)}<li>"
      dst += content
      if @tokens[@i].type == :EOL
        @i += 1
      else
        raise 'expected eol'
      end
      if @i + 1 < @tokens.length && @tokens[@i].type == :INDENT && @tokens[@i].text.length / 2 > indent && (@tokens[@i + 1].type == :BULLET || @tokens[@i + 1].type == :INT)
        dst += "\n"
        puts @tokens[@i].text.length / 2
        puts indent
        puts @tokens[@i].inspect
        puts @tokens[@i + 1].inspect
        dst += list indent + 1
        dst += ' ' * 2 * indent
      end
      dst += "</li>\n"
    end
    dst += "#{' ' * 2 * indent}</#{list_type == :BULLET ? 'u' : 'o'}l>\n"

    dst
  end

  def just_saw_comment
    i_last_non_eol = @i
    while i_last_non_eol > 0 && @tokens[i_last_non_eol].type == :EOL
      i_last_non_eol -= 1
    end
    i_last_non_eol >= 2 && @tokens[i_last_non_eol - 2].type == :LEFT_BRACKET && @tokens[i_last_non_eol - 1].type == :COMMENT && @tokens[i_last_non_eol].type == :RIGHT_BRACKET
  end

  def line
    dst = ''

    if @tokens[@i].type == :HASHES || @tokens[@i].type == :COUNTED_HASHES
      rank = @tokens[@i].text.length
      real_rank = rank
      rank += 2 # if @target == 'wordpress' # HEADER TAGS
      dst += "<h#{rank}>"
      if @tokens[@i].type == :COUNTED_HASHES
        # lesser ranks go back to 0
        for ri in real_rank...@counters.size
          @counters[ri] = 0
        end
        @counters[real_rank - 1] += 1
        dst += @counters.take(real_rank).map(&:to_s).join('.') + '. '
      end
      @i += 1
      dst += content
      dst += "</h#{rank}>\n"
      if @tokens[@i].type == :EOL
        @i += 1
      else
        raise "Expected end-of-line, found #{@tokens[@i].type}"
      end
    elsif @tokens[@i].type == :LINE
      if @styles.has_key? 'gray.line'
        dst += "<hr style=\"#{@styles['gray.line']}\">"
      else
        dst += '<hr>'
      end
      @i += 1
    elsif @tokens[@i].type == :INDENT
      @i += 1
    elsif @tokens[@i].type == :BULLET
      dst += list 0
    elsif @tokens[@i].type == :INT
      dst += list 0
    else
      dst += content

      # Don't add a linebreak after a comment tag.
      dst += "\n" if !just_saw_comment

      if @tokens[@i].type == :EOL
        @i += 1
      else
        raise "Expected end-of-line, found #{@tokens[@i].type}"
      end
    end

    dst
  end

  def first_of_content? type
    ([:CONTENT, :LEFT_BRACKET, :COMMENT].member? type) || (type == :BACKTICK && !@is_in_backtick) || (type == :STAR && !@is_in_asterisk) || (type == :STARSTAR && !@is_in_starstar) || (type == :EMDASH)
  end

  def first_of_line? type
    ([:COUNTED_HASHES, :HASHES, :LINE, :INDENT, :BULLET, :INT, :EOL].member? type) || first_of_content?(type)
  end

  def parse_attributes
    attributes = Hash.new
    while @tokens[@i].type == :IDENTIFIER
      key = @tokens[@i].text
      @i += 1
      if @tokens[@i].type == :EQUALS
        @i += 1
      else
        raise "expected =, found #{@tokens[@i].type}"
      end
      if @tokens[@i].type == :QUOTED_VALUE || @tokens[@i].type == :UNQUOTED_VALUE || @tokens[@i].type == :IDENTIFIER
        value = @tokens[@i].text
        @i += 1
      else
        raise "expected =, found #{@tokens[@i].type}"
      end
      attributes[key] = value
    end
    attributes
  end

  def count_preceding_linebreaks
    n = 0
    pi = @i - 1
    while pi >= 0
      # puts @tokens[pi].inspect
      if @tokens[pi].type == :EOL
        n += 1
        # puts n
        pi -= 1
      elsif pi >= 2 && @tokens[pi - 2].type == :LEFT_BRACKET && @tokens[pi - 1].type == :COMMENT && @tokens[pi].type == :RIGHT_BRACKET
        pi -= 3
      else
        break
      end
    end
    # puts
    n
  end

  def is_comment
    @tokens[@i].type == :LEFT_BRACKET && @tokens[@i + 1].type == :COMMENT && @tokens[@i + 2].type == :RIGHT_BRACKET
  end

  def is_block
    @tokens[@i].type == :LEFT_BRACKET && @tokens[@i + 1].type == :IDENTIFIER &&
    (@tokens[@i + 1].text == 'block' ||
     @tokens[@i + 1].text == 'code' ||
     @tokens[@i + 1].text == 'hide' ||
     @tokens[@i + 1].text == 'listveil')
  end

  def is_code
    @tokens[@i].type == :LEFT_BRACKET && @tokens[@i + 1].type == :IDENTIFIER && @tokens[@i + 1].text == 'code'
  end

  def content
    dst = ''

    # Need a paragraph?
    # puts "checking before #{@tokens[@i].inspect}"
    needs_paragraph = (count_preceding_linebreaks >= 2 || @i == 0) && !is_comment && !is_block && @tokens[@i].type != :EOL
    dst += "<p class=\"grayblock\">" if needs_paragraph

    while first_of_content? @tokens[@i].type
      if @tokens[@i].type == :CONTENT
        dst += @tokens[@i].text
        @i += 1
        is_first_content = false
      elsif @tokens[@i].type == :BACKTICK
        @i += 1
        dst += '<code>'
        @is_in_backtick = true
        if @tokens[@i].type != :CODE
          raise "expected backtick, found #{@tokens[@i].inspect}"
        end
        dst += entitize(@tokens[@i].text)#.gsub(/ {2,}/) do |match|
          # '&nbsp;' * match.length
        # end
        @i += 1
        if @tokens[@i].type == :BACKTICK
          @i += 1
        else
          raise "expected backtick, found #{@tokens[@i].inspect}"
        end
        @is_in_backtick = false
        dst += '</code>'
      elsif @tokens[@i].type == :STAR
        @i += 1
        dst += '<em>'
        @is_in_asterisk = true
        dst += content
        if @tokens[@i].type == :STAR
          @i += 1
        else
          raise "expected asterisk, found #{@tokens[@i].inspect}"
        end
        @is_in_asterisk = false
        dst += '</em>'
      elsif @tokens[@i].type == :EMDASH
        @i += 1
        dst += '&mdash;'
      elsif @tokens[@i].type == :STARSTAR
        @i += 1
        dst += '<b>'
        @is_in_starstar = true
        dst += content
        if @tokens[@i].type == :STARSTAR
          @i += 1
        else
          raise "expected starstar, found #{@tokens[@i].inspect}"
        end
        @is_in_starstar = false
        dst += '</b>'
      elsif @tokens[@i].type == :LEFT_BRACKET
        @i += 1

        dst += handle_command

        if @tokens[@i].type == :RIGHT_BRACKET
          @i += 1
        else
          puts dst
          raise "expected ], found #{@tokens[@i].inspect}"
        end
      end
    end

    dst += "</p>" if needs_paragraph

    dst
  end

  def handle_command
    dst = ''

    # Comments
    if @tokens[@i].type == :COMMENT
      dst += "<!-- #{@tokens[@i].text} -->" if @target != 'wordpress'
      @i += 1

    # Style definitions
    elsif @tokens[@i].type == :STYLE
      @i += 1
      if @tokens[@i].type == :IDENTIFIER
        key = @tokens[@i].text
        @i += 1
      else
        raise "wanted ID"
      end

      lines = []
      while @tokens[@i].type == :STYLE_LINE
        lines << @tokens[@i].text
        @i += 1
      end 

      @styles[key] = lines.map { |line| "#{line};" }.join(' ')

    # Macro
    elsif @tokens[@i].type == :IDENTIFIER
      command = @tokens[@i].text
      @i += 1
      attributes = parse_attributes

      # Expand style key.
      if attributes.has_key? 'style'
        attributes['style'] = @styles[attributes['style']]
      end

      if command == "link"
        blacklist = %w{to title}
        attributes_string = attributes.reject { |key, _| blacklist.include? key }.map { |key, value| " #{key}=\"#{value}\"" }.join
        dst += "<a href=\"#{attributes['to']}\"#{attributes_string}>#{attributes['title']}</a>"

      elsif command == "table"
        dst += "<table>\n"
        if @tokens[@i].type == :EOL
          @i += 1
        else
          raise 'expected EOL'
        end

        irow = 0

        while @tokens[@i].type != :RIGHT_BRACKET
          cell_letter = (irow == 0 && attributes.has_key?('headers') && attributes['headers'] == 'true') ? 'h' : 'd'
          icolumn = 0

          def get_cell_style attributes, col
            if attributes.has_key?('align') && col < attributes['align'].length
              case attributes['align'][col]
                when 'r'
                  "text-align: right"
                when 'c'
                  "text-align: center"
                else
                  "text-align: left"
              end
            else
              "text-align: left"
            end
          end

          dst += "  <tr>\n    <t#{cell_letter} style=\"#{get_cell_style attributes, icolumn}\">\n"
          while @tokens[@i].type != :EOL
            while @tokens[@i].type != :SEPARATOR && @tokens[@i].type != :EOL
              dst += content
            end
            if @tokens[@i].type == :SEPARATOR
              icolumn += 1
              dst += "\n    </t#{cell_letter}>\n    <t#{cell_letter} style=\"#{get_cell_style attributes, icolumn}\">\n"
              @i += 1
            end
          end
          dst += "\n    </t#{cell_letter}>\n  </tr>\n"
          @i += 1
          irow += 1
        end
        dst += "</table>"

      elsif command == "javascript"
        src = attributes['src']
        if @target == 'wordpress'
          if src !~ /https?:\/\// && @root
            src = "#{@root}/#{src}"
          end
          dst += "[emjs src=\"#{src}\"]"
        else
          dst += "<script src=\"#{src}\"></script>"
        end
        
      elsif command == "frame"
        s = attributes.map { |key, value| ['src', 'autosize'].member?(key) ? '' : " #{key}=\"#{value}\"" }.join
        if attributes.has_key?('autosize') && attributes['autosize'] == 'true' && attributes.has_key?('id')
          if @target == 'wordpress'
            autosize_attribute = " autosize=\"true\""
          else
            autosize_attribute = " onload=\"autosize('#{attributes['id']}')\"";
          end
        else
          autosize_attribute = ""
        end
        if @target == 'wordpress'
          src = attributes['src']
          if src !~ /https?:\/\// && @root
            src = "#{@root}/#{src}"
          end
          dst += "[frame src=\"#{src}\"#{s}#{autosize_attribute}]"
        else
          dst += "<iframe src=\"#{attributes['src']}\"#{s}#{autosize_attribute} frameborder=\"0\"></iframe>"
        end

      elsif command == "youtube"
        attributes['src'].gsub!(/youtu\.be/, 'www.youtube.com/embed')
        s = attributes.map { |key, value| key == 'src' ? '' : " #{key}=\"#{value}\"" }.join
        if @target == 'wordpress'
          dst += "[frame src=\"#{attributes['src']}\"#{s} frameborder=\"0\" allowfullscreen]"
        else
          dst += "<iframe src=\"#{attributes['src']}\"#{s} frameborder=\"0\" allowfullscreen></iframe>"
        end
      elsif command == "timedown"
        if @target == 'wordpress'
          dst += "[timedown seconds=#{attributes['seconds']} id=timedown1]"
        else
          dst += "<script>generateTimedown(#{attributes['seconds']}, 'timedown1');</script>"
        end
      elsif command == "span"

      elsif command == "redacted"
        dst += '&#9608;&#9608;&#9608;&#9608;&#9608;&#9608;'

      elsif command == "image"
        s = attributes.map { |key, value| (key == 'src' || key == 'selflink' || (key == 'style' && attributes.has_key?('caption'))) ? '' : " #{key}=\"#{value}\"" }.join
        # TODO, if src is not relative, don't prefix it

        # if attributes.has_key?('caption')
          # if !attributes.has_key?('width')
            # raise 'caption, but no width!'
          # end
          # dst += "<div style=\"#{attributes['style']}\">"
        # end
        dst += "<figure style=\"width: #{attributes['width']}px;\" class=\"#{attributes['class']}\">"

        path = attributes['src']
        if path !~ /^https?:\/\//
          path = "#{@root}/#{path}"
        end

        is_selflink = attributes.has_key?('selflink') && attributes['selflink'] == 'true'
        if is_selflink
          dst += "<a href=\"#{path}\">"
        end
        dst += "<img src=\"#{path}\"#{s}>"
        if is_selflink
          dst += "</a>"
        end

        if attributes.has_key? 'caption'
          # dst += "<br><span"
          # if attributes.has_key? 'width'
            # dst += " style=\"width: #{attributes['width']}; margin-left: auto; margin-right: auto;\""
          # end
          # dst += "><i><small>" + attributes['caption'] + "</small></i></span>"
          dst += "<figcaption>#{attributes['caption']}</figcaption>"
        end
        dst += "</figure>"
      else
        pair_string = attributes.map { |key, value| " #{key}=\"#{value}\"" }.join

        if command != 'code' || !attributes.has_key?('file')
          if @tokens[@i].type == :EOL
            @i += 1
          elsif @tokens[@i].type == :SEPARATOR
          else
            raise "expected EOL, found #{@tokens[@i].type}"
          end
        end

        if command == 'code'
          if attributes.has_key?('hide')
            dst += "<div class=\"indented grayblock\">"
            dst += "<a href=\"#\" class=\"toggler\">#{attributes['hide']}</a>"
            dst += '<div class="togglee">'
          end

          code = ''
          if attributes.has_key? 'file'
            code = IO.read(attributes['file'])
          else
            while @i < @tokens.length && (@tokens[@i].type == :CODE || @tokens[@i].type == :EOL)
              if @tokens[@i].type == :CODE
                if @i + 2 < @tokens.length && @tokens[@i + 2].type == :CODE
                  code += "#{@tokens[@i].text}\n"
                else
                  code += @tokens[@i].text
                end
                @i += 1
              else
                code += "\n\n"
              end
              if @tokens[@i].type == :EOL
                @i += 1
              else
                raise "expected EOL after code, found #{@tokens[@i].type}"
              end
            end
          end

          if attributes.has_key?('scrambled')
            dst += '<div class="scramblebox">'
            dst += '<ol class="scrambled">'
            code.lines.each do |line|
              if attributes.has_key? 'lang'
                dst += '<li>'
                IO.popen("coderay -#{attributes['lang']} -div", 'r+') do |pipe|
                  pipe.puts line.chomp
                  pipe.close_write
                  code = pipe.read
                  dst += code.chomp
                end
                dst += '</li>'
              else
                dst += "<li><pre>#{line.chomp}</pre></li>"
              end
            end
            dst += '</ol>'
            dst += '<p class="grayblock"><input type="button" class="scramble" value="Scramble"></p>'
            dst += '</div>'
          else
            if attributes.has_key? 'lang'
              IO.popen("coderay -#{attributes['lang']} -div", 'r+') do |pipe|
                pipe.puts code
                pipe.close_write
                code = pipe.read
                dst += "<div#{pair_string}>#{code}</div>"
              end
            else
              dst += "<pre#{pair_string}>"
              dst += entitize(code)
              dst += '</pre>'
            end
          end

          if attributes.has_key?('hide')
            dst += '</div>'
            dst += '</div>'
          end

        elsif command == 'raffle'
          choices = []
          while @i < @tokens.length && (@tokens[@i].type != :RIGHT_BRACKET)
            choices << line.chomp
          end

          if @target == 'wordpress'
            dst += "[raffle id=#{attributes['id']}]#{choices.join("\n")}[/raffle]"
          else
            dst += <<EOF
<script>
var raffle_choices_#{attributes['id']} = [#{choices.map { |choice| "'#{choice}'" }.join(', ')}];
shuffle(raffle_choices_#{attributes['id']});
</script>
<div id="#{attributes['id']}" style="user-select: none; text-align: center; font-size: 24pt;" onclick="raffle(this, raffle_choices_#{attributes['id']});">
click for a random term...
</div>
EOF
          end

        elsif command == 'latex'
          ['id'].each do |key|
            if !attributes.has_key? key
              raise "latex snippet must have #{key} attribute!"
            end
          end

          latex_source = <<'EOF'
\documentclass[fleqn]{article}
\usepackage{mathtools}
\usepackage{amsmath}
\usepackage[active,tightpage,textmath,displaymath,pdftex]{preview}
\begin{document}
\makeatletter\setlength\@mathmargin{0pt}\makeatother
EOF
          while @i < @tokens.length && @tokens[@i].type == :CODE
            latex_source += @tokens[@i].text
            @i += 1

            if @tokens[@i].type == :EOL
              @i += 1
            else
              raise "expected EOL after latex, found #{@tokens[@i].type}"
            end
          end
          latex_source += "\n\\end{document}"

          # IO.popen("pdflatex -jobname=#{attributes['id']} && gs -sDEVICE=png16m -dTextAlphaBits=4 -r144 -dGraphicsAlphaBits=4 -dSAFER -q -dNOPAUSE -dBATCH -sOutputFile=#{attributes['id']}.png #{attributes['id']}.pdf && mogrify -quality 100 -resize #{attributes['width']}x#{attributes['height']} #{attributes['id']}.png", 'w+') do |pipe|
          IO.popen("pdflatex -jobname=#{attributes['id']} && (pdftoppm -rx 400 -ry 400 -png #{attributes['id']}.pdf > #{attributes['id']}.png)", 'w+') do |pipe|
            pipe.write(latex_source)
            pipe.close_write
            pipe.read.split("\n").each do |line|
              STDERR.puts line
            end
          end

          dst += "<img src=\"#{@root}/#{attributes['id']}.png\"#{s} style=\"#{@styles['latex_math']}\">"

        elsif command == 'listveil'
          if attributes.has_key?('class') 
            attributes['class'] += ' listveil'
          else
            attributes['class'] = 'listveil'
          end

          pair_string = attributes.map { |key, value| " #{key}=\"#{value}\"" }.join

          dst += "<div#{pair_string}>\n"
          while @i < @tokens.length && (first_of_line? @tokens[@i].type)
            dst += line
          end
          dst += '</div>'

        elsif command == 'lineveil'
          dst += "<pre#{pair_string}>"
          li = 0
          while @i < @tokens.length && @tokens[@i].type == :CODE
            dst += "#{'&nbsp;' * (2 - li.to_s.length)}<a href=\"#\" class=\"lineveil\">#{li}</a>: <span class=\"lineveil\">#{@tokens[@i].text}</span>"
            if @i + 2 < @tokens.length && @tokens[@i + 2].type == :CODE
              dst += "\n"
            end
            @i += 1
            if @tokens[@i].type == :EOL
              @i += 1
            else
              raise "expected EOL after code, found #{@tokens[@i].type}"
            end
            li += 1
          end
          dst += '</pre>'
        elsif command == 'madeup'
          ['id', 'width', 'height'].each do |key|
            if !attributes.has_key? key
              raise "madeup snippet must have #{key} attribute!"
            end
          end

          code = ''
          while @i < @tokens.length && (@tokens[@i].type != :RIGHT_BRACKET)
            code += @tokens[@i].text
            @i += 1
          end
          code.gsub!(/'/, '\\\\\'')

          if @target == 'wordpress'
            dst += <<EOF
<pre>[mup id=#{attributes['id']} width=#{attributes['width']} height=#{attributes['height']} frameborder="0"]#{code}[/mup]</pre>
EOF
          else
            dst += <<EOF
<div id="mup_#{attributes['id']}">
<form style="display: none" id="mup_form_#{attributes['id']}" target="mup_frame_#{attributes['id']}" action="http://embed.madeup.xyz" method="post">
<textarea name="src">#{code}</textarea>
<input type="submit"/>
</form>
<iframe name=\"mup_frame_#{attributes['id']}\" src=\"\" width=\"#{attributes['width']}\" height=\"#{attributes['height']}\" frameborder=\"0\"></iframe>
<script>
document.getElementById('mup_form_#{attributes['id']}').submit();
</script>
</div>
EOF
          end

        elsif command == 'quote'
          dst += "<blockquote#{pair_string}>"
          while @i < @tokens.length && (first_of_content?(@tokens[@i].type) || @tokens[@i].type == :EOL)
            dst += content
            dst += "\n" if @i + 1 < @tokens.length && @tokens[@i + 1].type != :RIGHT_BRACKET
            if @tokens[@i].type == :EOL
              @i += 1
            else
              raise "expected EOL after quote content, found #{@tokens[@i].type}"
            end
          end
          dst += '</blockquote>'
        elsif command == 'hide'
          is_indented = attributes.has_key?('indent') && attributes['indent'] == 'true'
          dst += "<div class=\"indented grayblock\">" if is_indented
          dst += "<a href=\"#\" class=\"toggler\">#{attributes['title']}</a>"
          classes = attributes.has_key?('class') ? ' ' + attributes['class'] : ''
          dst += "<div class=\"togglee#{classes}\">"
          if @tokens[@i].type == :SEPARATOR
            @i += 1
            dst += handle_command
          else
            dst += content
            if @tokens[@i].type == :EOL
              @i += 1
            else
              raise "expected EOL after hide content, found #{@tokens[@i].type}"
            end
          end
          dst += '</div>'
          dst += '</div>' if is_indented
        elsif command == 'haiku'
          dst += "<blockquote#{pair_string}>"
          is_first = true
          while @i < @tokens.length && (first_of_content? @tokens[@i].type)
            if !is_first
              dst += '<br>'
            else
              is_first = false
            end
            dst += content
            # dst += "\n" if @i + 1 < @tokens.length && @tokens[@i + 1].type != :RIGHT_BRACKET
            if @tokens[@i].type == :EOL
              @i += 1
            else
              raise "expected EOL after quote content, found #{@tokens[@i].type}"
            end
          end
          dst += '</blockquote>'
        elsif command == 'block'
          if attributes.has_key?('hide')
            dst += "<div class=\"grayblock indented\">"
            dst += "<a href=\"#\" class=\"toggler\">#{attributes['hide']}</a>"
            if attributes.has_key?('class')
              attributes['class'].gsub!(/"?$/, ' togglee')
            else
              attributes['class'] = 'togglee'
            end
          end

          pair_string = attributes.map { |key, value| " #{key}=\"#{value}\"" }.join

          dst += "<div#{pair_string}>\n"
          while @i < @tokens.length && (first_of_line? @tokens[@i].type)
            dst += line
          end
          dst += '</div>'

          if attributes.has_key?('hide')
            dst += '</div>'
          end
        elsif command == 'strike'
          dst += '<strike>'
          if @tokens[@i].type == :SEPARATOR
            @i += 1
            dst += handle_command
          else
            while @i < @tokens.length && (first_of_line? @tokens[@i].type)
              dst += line
            end
          end
          dst += '</strike>'
        elsif command == 'toggle'
          dst += "<div class=\"toggle\"#{pair_string}>"
          while @i < @tokens.length && (first_of_content? @tokens[@i].type)
            dst += content
            dst += "\n" if @i + 1 < @tokens.length && @tokens[@i + 1].type != :RIGHT_BRACKET
            if @tokens[@i].type == :EOL
              @i += 1
            else
              raise "expected EOL after toggle content, found #{@tokens[@i].type}"
            end
          end
          dst += '</div>'
        end
      end
    else
      raise 'expected ID'
    end

    dst
  end
end

src = File.read(path)
lexer = Lexer.new src
lexer.lex
parser = Parser.new lexer.tokens, target
puts parser.parse
