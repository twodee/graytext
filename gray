#!/usr/bin/env ruby

$config = Hash.new

command = ARGV.shift

def configure path
  dir = File.expand_path(path)
  $offset = ''
  loop do
    dir = File.dirname(dir)
    rc_file = dir + '/.grayrc'
    if File.exists?(rc_file)
      lines = IO.read(rc_file).lines.grep(/(.*?)\s*=\s*(.*?)/)
      $config = lines.map { |line| line.chomp.split(/\s*=\s*/) }.to_h
      break
    end
    break if dir == '/'
    $offset = File.basename(dir) + '/' + $offset
  end

  $offset.gsub!(/\/$/, '')
end

if command == 'upload'
  ARGV.each do |path|
    configure path

    dir = "/var/www/html/#{$config['root']}/#{$offset}".gsub(/\/{2,}/, '/')

    command = "ssh twodee 'mkdir -p #{dir} && umask 0017 && chmod -R g+X /var/www/html/#{$config['root']}/#{$offset.gsub(/\/.*$/, '')}' && scp #{path} twodee:#{dir} && ssh twodee 'chmod g+r #{dir}/#{File.basename(path)}'"
    puts command
    `#{command}`

    puts
  end

  exit 0
elsif command == 'code'
  path = ARGV.shift 
  code = ''
  ARGV.each_with_index do |codepath, i|
    if i > 0
      code += "\n\n"
    end
    code += "## #{File.basename(codepath)}\n\n"
    language = case File.extname(codepath)
      when '.java'
        'java'
      when '.mup'
        'madeup'
      when '.cpp', '.h'
        'cpp'
      when '.rb'
        'ruby'
      when '.zsh'
        'zsh'
      else
        ''
      end
    language = " lang=#{language}" if !language.empty?
    code += "[code#{language}\n"
    code += IO.read(codepath).gsub(/\t/, '  ').chomp
    code += "\n]\n"
  end

  text = IO.read(path)
  if !text.gsub!(/(?<=\[" CODE START\]\n).*?(?=\n\[" CODE END\])/m, code)
    text.sub!(/\s*\Z/, "\n\n[\" CODE START]\n#{code}\n[\" CODE END]\n")
  end

  File.open(path, 'w') do |file|
    file.write(text)
  end

  exit 0

end

target = ARGV[0]
path = ARGV[1]
configure path

class Token
  attr_reader :type, :text

  def initialize type, text = ''
    @type = type
    @text = text
  end
end

class Lexer
  attr_reader :tokens, :src

  def initialize src
    @src = src.dup
  end

  def lex
    @states = [:default, :linestart]
    @tokens = []
    @i = 0

    token = nil
    until token && token.type == :EOF
      token = get_token
      STDERR.puts "#{token.inspect} -- now in #{@states[-1]} -- #{@states.inspect}"
      @tokens << token
    end
  end

  def get_token
    @token_so_far = ''

    if @i >= src.length
      Token.new :EOF
    elsif @states[-1] == :linestart
      get_linestart_token
    elsif @states[-1] == :default
      get_default_token
    elsif @states[-1] == :table
      get_table_token
    elsif @states[-1] == :blockcode
      get_block_code_token
    elsif @states[-1] == :command
      get_command
    elsif @states[-1] == :attributes
      get_attributes
    elsif @states[-1] == :style_name
      get_style_name
    elsif @states[-1] == :inline_code
      get_token_after_backtick
    elsif @states[-1] == :style_lines
      get_style_lines
    elsif @states[-1] == :eatspace
      until @i >= src.length || @src[@i] != ' '
        @i += 1
      end
      @states.pop
      get_token
    end
  end

  def get_command
    rest = @src[@i..-1]
    if rest =~ /\Astyle/
      @i += $&.length
      while @src[@i] == ' '
        @i += 1
      end
      @states[-1] = :style_name
      Token.new :STYLE, $&
    elsif @src[@i] =~ /[A-Za-z0-9]/
      while @i < @src.length && @src[@i] =~ /[A-Za-z0-9]/
        @token_so_far << @src[@i]
        @i += 1
      end
      @id = @token_so_far
      @states[-1] = :attributes
      Token.new :IDENTIFIER, @token_so_far
    elsif @src[@i] == '"'
      # Skip over ".
      @i += 1

      # Skip over whitespace.
      while @i < @src.length && @src[@i] =~ /[ \t]/
        @i += 1
      end

      @token_so_far = ''
      while @i < @src.length && @src[@i] != ']'
        @token_so_far << @src[@i]
        @i += 1
      end

      @states[-1] = :default
      Token.new :COMMENT, @token_so_far
    else
      raise "I dunno #{@src[@i..-1]}"
    end
  end

  def get_style_name
    # rest = @src[@i..-1]
    # puts rest

    @token_so_far = ''
    while @i < @src.length && @src[@i] =~ /\w|\.|\d/
      @token_so_far << @src[@i]
      @i += 1
    end

    if @src[@i] == "\n"
      @i += 1
    else
      raise "ouch"
    end

    @states[-1] = :style_lines
    Token.new :IDENTIFIER, @token_so_far
  end

  def get_style_lines
    if @src[@i] == ']'
      @i += 1
      @states[-1] = :default
      Token.new :RIGHT_BRACKET, ']'
    else
      @token_so_far = ''
      while @i < @src.length && @src[@i] != "\n"
        @token_so_far << @src[@i]
        @i += 1
      end

      if @src[@i] == "\n"
        @i += 1
      else
        raise "ouch2"
      end

      Token.new :STYLE_LINE, @token_so_far
    end
  end

  def get_attributes
    while @src[@i] == ' '
      @i += 1
    end

    if @src[@i] == "\n"
      if @id == 'code' || @id == 'lineveil' || @id == 'madeup' || @id == 'latex' # Any code blocks
        @states[-1] = :blockcode
      elsif @id == 'block'
        @states[-1] = :linestart
      elsif @id == 'table'
        @states[-1] = :table
      else
        @states[-1] = :default
      end
      @i += 1
      Token.new :EOL, "\n"
    elsif @src[@i] == ']'
      @i += 1
      @states[-1] = :default
      Token.new :RIGHT_BRACKET, ']'
    elsif @src[@i] == '='
      @i += 1
      Token.new :EQUALS, '='
    elsif @src[@i] == '"'
      @i += 1
      value = ''
      while @i < @src.length && @src[@i] != '"'
        # Allow escaped.
        if @i < @src.length - 1 && @src[@i] == '\\'
          @i += 1
        end
        @token_so_far << @src[@i]
        @i += 1
      end
      if @src[@i] == '"'
        @i += 1
      end
      Token.new :QUOTED_VALUE, @token_so_far
    elsif @src[@i] !~ /[= \]\n]/
      while @i < @src.length && @src[@i] !~ /[= \]\n]/
        @token_so_far << @src[@i]
        @i += 1
      end
      if @token_so_far =~ /^[A-Za-z][A-Za-z0-9]+$/
        Token.new :IDENTIFIER, @token_so_far
      else
        Token.new :UNQUOTED_VALUE, @token_so_far
      end
    end
  end

  def get_linestart_token
    rest = @src[@i..-1]

    if rest =~ /\A(\d+)\.\s+/
      @i += $&.length
      @states.pop
      Token.new :INT, @token_so_far
    elsif rest =~ /\A-{5,}\r?\n/
      @i += $&.length
      Token.new :LINE, @token_so_far
    else
      c = src[@i]
      @i += 1
      @token_so_far << c

      case c
        when ' '
          get_token_indent
        when '-'
          @states[-1] = :eatspace
          Token.new :BULLET, @token_so_far
        when '#'
          get_token_after_hash
        else
          @i -= 1
          @token_so_far = ''
          @states.pop
          @states.push :default
          get_default_token
      end
    end
  end

  def get_table_token
    get_default_token
  end

  def get_token_after_hash
    while @i < @src.length && @src[@i] == '#'
      @token_so_far << @src[@i]
      @i += 1
    end

    @states.push :default
    @states.push :eatspace

    if @i < @src.length && @src[@i] == '.'
      @i += 1
      Token.new :COUNTED_HASHES, @token_so_far
    else
      Token.new :HASHES, @token_so_far
    end
  end

  def get_default_token
    c = src[@i]
    @i += 1
    @token_so_far << c

    case c
      when "\n"
        @states.push :linestart
        Token.new :EOL, @token_so_far
      when '*'
        get_token_after_asterisk
      when '`'
        @states.push :inline_code
        Token.new :BACKTICK, @token_so_far
      when '['
        @states.push :command
        Token.new :LEFT_BRACKET, @token_so_far
      when ']'
        @states.pop
        Token.new :RIGHT_BRACKET, @token_so_far
      when '-'
        get_token_after_dash
      when '\\'
        get_token_after_backslash
      when '|'
        if @states[-1] == :table
          Token.new :COLUMN_SEPARATOR, @token_so_far 
        else
          get_token_content
        end
      else
        get_token_content
    end
  end

  def get_token_after_backslash
    # Replace the slash we just read with the succeeding character.
    if @i < @src.length
      @token_so_far[-1] = src[@i]
      @i += 1
    end
    get_default_token
  end

  def get_token_after_backtick
    c = src[@i]
    @i += 1
    @token_so_far << c

    if c == '`'
      @states.pop
      Token.new :BACKTICK, @token_so_far
    else
      while @i < @src.length && @src[@i] != '`'
        @token_so_far << @src[@i]
        @i += 1
      end
      Token.new :CODE, @token_so_far
    end
  end

  def get_token_after_dash
    if @i + 1 < @src.length && @src[@i] == '-' && @src[@i + 1] == '-'
      @i += 2
      Token.new :EMDASH, '---'
    else
      get_token_content
    end
  end

  def get_token_after_asterisk
    if @i < @src.length && @src[@i] == '*'
      @i += 1
      Token.new :STARSTAR, @token_so_far
    else
      Token.new :STAR, @token_so_far
    end
  end

  def get_block_code_token
    if @src[@i..-1] =~ /\A([ \t]*\])/
      @i += $1.length
      @states.pop
      Token.new :RIGHT_BRACKET, ']'
    elsif @src[@i] == "\n"
      @i += 1
      Token.new :EOL, "\n"
    else
      while @i < @src.length && @src[@i] != "\n"
        @token_so_far << @src[@i]
        @i += 1
      end
      Token.new :CODE, @token_so_far.gsub(/\A\\\]/, ']')
    end
  end

  def get_token_content
    while @i < @src.length && @src[@i] != "\n" && @src[@i] != '`' && @src[@i] != '*' && @src[@i] != '[' && @src[@i] != '-' && (@states[-1] != :table || @src[@i] != '|')
      # Skip
      if @src[@i] == '\\' && @i + 1 < @src.length
        @i += 1
      end
      @token_so_far << @src[@i]
      @i += 1
    end
    Token.new :CONTENT, @token_so_far
  end

  def get_token_indent
    while @i < @src.length && @src[@i] == ' '
      @token_so_far << @src[@i]
      @i += 1
    end
    Token.new :INDENT, @token_so_far
  end
end

class Parser
  def initialize tokens, target
    @tokens = tokens
    @target = target
    @root = nil
    @styles = Hash.new
    @counters = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

    @tokens.each do |token|
      if token.type == :COMMENT
        if token.text =~ /\broot\s*=\s*(\S+)/
          @root = $1
        end
      end
    end

    if @target == 'wordpress'
      @root = $config['root'] + '/' + $offset
    end
    
    # puts @root
  end

  def entitize code
    code.gsub(/&/, '&amp;').gsub(/</, '&lt;').gsub(/>/, '&gt;')
  end

  def parse
    dst = ''
    if @target == 'html'
      header = IO.read(File.dirname(__FILE__) + '/bubbles_header.html')
      header.gsub!(/(?<=<style>)(?=<\/style>)/, IO.read(File.dirname(__FILE__) + '/style.css'))
      header.gsub!(/(?<=<script>)(?=<\/script>)/, IO.read(File.dirname(__FILE__) + '/utilities.js'))
      dst += header
    end

    @is_in_backtick = false
    @is_in_asterisk = false
    @is_in_starstar = false

    @i = 0
    until @tokens[@i].type == :EOF
      dst += line
    end

    if @target == 'html'
      dst += IO.read(File.dirname(__FILE__) + '/bubbles_footer.html')
    end

    dst
  end

  def list indent
    dst = ''

    if indent == 0
      list_type = @tokens[@i].type
    else
      list_type = @tokens[@i + 1].type
    end

    dst += "#{' ' * 2 * indent}<#{list_type == :BULLET ? 'u' : 'o'}l>\n"
    while (indent == 0 && @tokens[@i].type == list_type) || (@tokens[@i].type == :INDENT && @tokens[@i].text.length / 2 == indent && @tokens[@i + 1].type == list_type)
      if @tokens[@i].type == :INDENT
        @i += 1
      end
      @i += 1
      dst += "#{' ' * 2 * (indent + 1)}<li>"
      dst += content
      if @tokens[@i].type == :EOL
        @i += 1
      else
        raise 'expected eol'
      end
      if @i + 1 < @tokens.length && @tokens[@i].type == :INDENT && @tokens[@i].text.length / 2 > indent && (@tokens[@i + 1].type == :BULLET || @tokens[@i + 1].type == :INT)
        dst += "\n"
        puts @tokens[@i].text.length / 2
        puts indent
        puts @tokens[@i].inspect
        puts @tokens[@i + 1].inspect
        dst += list indent + 1
        dst += ' ' * 2 * indent
      end
      dst += "</li>\n"
    end
    dst += "#{' ' * 2 * indent}</#{list_type == :BULLET ? 'u' : 'o'}l>\n"

    dst
  end

  def just_saw_comment
    i_last_non_eol = @i
    while i_last_non_eol > 0 && @tokens[i_last_non_eol].type == :EOL
      i_last_non_eol -= 1
    end
    i_last_non_eol >= 2 && @tokens[i_last_non_eol - 2].type == :LEFT_BRACKET && @tokens[i_last_non_eol - 1].type == :COMMENT && @tokens[i_last_non_eol].type == :RIGHT_BRACKET
  end

  def line
    dst = ''

    if @tokens[@i].type == :HASHES || @tokens[@i].type == :COUNTED_HASHES
      rank = @tokens[@i].text.length
      real_rank = rank
      rank += 2 if @target == 'wordpress'
      dst += "<h#{rank}>"
      if @tokens[@i].type == :COUNTED_HASHES
        # lesser ranks go back to 0
        for ri in real_rank...@counters.size
          @counters[ri] = 0
        end
        @counters[real_rank - 1] += 1
        dst += @counters.take(real_rank).map(&:to_s).join('.') + '. '
      end
      @i += 1
      dst += content
      dst += "</h#{rank}>\n"
      if @tokens[@i].type == :EOL
        @i += 1
      else
        raise "Expected end-of-line, found #{@tokens[@i].type}"
      end
    elsif @tokens[@i].type == :LINE
      if @styles.has_key? 'gray.line'
        dst += "<hr style=\"#{@styles['gray.line']}\">"
      else
        dst += '<hr>'
      end
      @i += 1
    elsif @tokens[@i].type == :INDENT
      @i += 1
    elsif @tokens[@i].type == :BULLET
      dst += list 0
    elsif @tokens[@i].type == :INT
      dst += list 0
    else
      dst += content

      # Don't add a linebreak after a comment tag.
      dst += "\n" if !just_saw_comment

      if @tokens[@i].type == :EOL
        @i += 1
      else
        raise "Expected end-of-line, found #{@tokens[@i].type}"
      end
    end

    dst
  end

  def first_of_content? type
    ([:CONTENT, :LEFT_BRACKET, :COMMENT].member? type) || (type == :BACKTICK && !@is_in_backtick) || (type == :STAR && !@is_in_asterisk) || (type == :STARSTAR && !@is_in_starstar) || (type == :EMDASH)
  end

  def first_of_line? type
    ([:COUNTED_HASHES, :HASHES, :LINE, :INDENT, :BULLET, :INT, :EOL].member? type) || first_of_content?(type)
  end

  def parse_attributes
    attributes = Hash.new
    while @tokens[@i].type == :IDENTIFIER
      key = @tokens[@i].text
      @i += 1
      if @tokens[@i].type == :EQUALS
        @i += 1
      else
        raise "expected =, found #{@tokens[@i].type}"
      end
      if @tokens[@i].type == :QUOTED_VALUE || @tokens[@i].type == :UNQUOTED_VALUE || @tokens[@i].type == :IDENTIFIER
        value = @tokens[@i].text
        @i += 1
      else
        raise "expected =, found #{@tokens[@i].type}"
      end
      attributes[key] = value
    end
    attributes
  end

  def count_preceding_linebreaks
    n = 0
    pi = @i - 1
    while pi >= 0
      # puts @tokens[pi].inspect
      if @tokens[pi].type == :EOL
        n += 1
        # puts n
        pi -= 1
      elsif pi >= 2 && @tokens[pi - 2].type == :LEFT_BRACKET && @tokens[pi - 1].type == :COMMENT && @tokens[pi].type == :RIGHT_BRACKET
        pi -= 3
      else
        break
      end
    end
    # puts
    n
  end

  def is_comment
    @tokens[@i].type == :LEFT_BRACKET && @tokens[@i + 1].type == :COMMENT && @tokens[@i + 2].type == :RIGHT_BRACKET
  end

  def is_block
    @tokens[@i].type == :LEFT_BRACKET && @tokens[@i + 1].type == :IDENTIFIER && @tokens[@i + 1].text == 'block'
  end

  def is_code
    @tokens[@i].type == :LEFT_BRACKET && @tokens[@i + 1].type == :IDENTIFIER && @tokens[@i + 1].text == 'code'
  end

  def content
    dst = ''

    # Need a paragraph?
    # puts "checking before #{@tokens[@i].inspect}"
    needs_paragraph = (count_preceding_linebreaks >= 2 || @i == 0) && !is_comment && !is_block && !is_code && @tokens[@i].type != :EOL
    dst += "<p>" if needs_paragraph

    while first_of_content? @tokens[@i].type
      if @tokens[@i].type == :CONTENT
        dst += @tokens[@i].text
        @i += 1
        is_first_content = false
      elsif @tokens[@i].type == :BACKTICK
        @i += 1
        dst += '<code>'
        @is_in_backtick = true
        if @tokens[@i].type != :CODE
          raise "expected backtick, found #{@tokens[@i].inspect}"
        end
        dst += entitize(@tokens[@i].text)#.gsub(/ {2,}/) do |match|
          # '&nbsp;' * match.length
        # end
        @i += 1
        if @tokens[@i].type == :BACKTICK
          @i += 1
        else
          raise "expected backtick, found #{@tokens[@i].inspect}"
        end
        @is_in_backtick = false
        dst += '</code>'
      elsif @tokens[@i].type == :STAR
        @i += 1
        dst += '<em>'
        @is_in_asterisk = true
        dst += content
        if @tokens[@i].type == :STAR
          @i += 1
        else
          raise "expected asterisk, found #{@tokens[@i].inspect}"
        end
        @is_in_asterisk = false
        dst += '</em>'
      elsif @tokens[@i].type == :EMDASH
        @i += 1
        dst += '&mdash;'
      elsif @tokens[@i].type == :STARSTAR
        @i += 1
        dst += '<b>'
        @is_in_starstar = true
        dst += content
        if @tokens[@i].type == :STARSTAR
          @i += 1
        else
          raise "expected starstar, found #{@tokens[@i].inspect}"
        end
        @is_in_starstar = false
        dst += '</b>'
      elsif @tokens[@i].type == :LEFT_BRACKET
        @i += 1

        if @tokens[@i].type == :COMMENT
          dst += "<!-- #{@tokens[@i].text} -->" if @target != 'wordpress'
          @i += 1
        elsif @tokens[@i].type == :STYLE
          @i += 1
          if @tokens[@i].type == :IDENTIFIER
            key = @tokens[@i].text
            @i += 1
          else
            raise "wanted ID"
          end

          lines = []
          while @tokens[@i].type == :STYLE_LINE
            lines << @tokens[@i].text
            @i += 1
          end 

          @styles[key] = lines.map { |line| "#{line};" }.join(' ')
        elsif @tokens[@i].type == :IDENTIFIER
          command = @tokens[@i].text
          @i += 1
          attributes = parse_attributes

          # Expand style key.
          if attributes.has_key? 'style'
            attributes['style'] = @styles[attributes['style']]
          end

          if command == "link"
            blacklist = %w{to title}
            attributes_string = attributes.reject { |key, _| blacklist.include? key }.map { |key, value| " #{key}=\"#{value}\"" }.join
            dst += "<a href=\"#{attributes['to']}\"#{attributes_string}>#{attributes['title']}</a>"

          elsif command == "table"
            dst += "<table>\n"
            if @tokens[@i].type == :EOL
              @i += 1
            else
              raise 'expected EOL'
            end

            irow = 0

            while @tokens[@i].type != :RIGHT_BRACKET
              cell_letter = (irow == 0 && attributes.has_key?('headers') && attributes['headers'] == 'true') ? 'h' : 'd'
              icolumn = 0

              def get_cell_style attributes, col
                if attributes.has_key?('align') && col < attributes['align'].length
                  case attributes['align'][col]
                    when 'r'
                      "text-align: right"
                    when 'c'
                      "text-align: center"
                    else
                      "text-align: left"
                  end
                else
                  "text-align: left"
                end
              end

              dst += "  <tr>\n    <t#{cell_letter} style=\"#{get_cell_style attributes, icolumn}\">\n"
              while @tokens[@i].type != :EOL
                while @tokens[@i].type != :COLUMN_SEPARATOR && @tokens[@i].type != :EOL
                  dst += content
                end
                if @tokens[@i].type == :COLUMN_SEPARATOR
                  icolumn += 1
                  dst += "\n    </t#{cell_letter}>\n    <t#{cell_letter} style=\"#{get_cell_style attributes, icolumn}\">\n"
                  @i += 1
                end
              end
              dst += "\n    </t#{cell_letter}>\n  </tr>\n"
              @i += 1
              irow += 1
            end
            dst += "</table>"
            
          elsif command == "frame"
            s = attributes.map { |key, value| ['src', 'autosize'].member?(key) ? '' : " #{key}=\"#{value}\"" }.join
            if attributes.has_key?('autosize') && attributes['autosize'] == 'true' && attributes.has_key?('id')
              if @target == 'wordpress'
                autosize_attribute = " autosize=\"true\""
              else
                autosize_attribute = " onload=\"autosize('#{attributes['id']}')\"";
              end
            else
              autosize_attribute = ""
            end
            if @target == 'wordpress'
              src = attributes['src']
              if src !~ /https?:\/\// && @root
                src = "#{@root}/#{src}"
              end
              dst += "[frame src=\"#{src}\"#{s}#{autosize_attribute}]"
            else
              dst += "<iframe src=\"#{attributes['src']}\"#{s}#{autosize_attribute}></iframe>"
            end

          elsif command == "youtube"
            attributes['src'].gsub!(/youtu\.be/, 'www.youtube.com/embed')
            s = attributes.map { |key, value| key == 'src' ? '' : " #{key}=\"#{value}\"" }.join
            if @target == 'wordpress'
              dst += "[frame src=\"#{attributes['src']}\"#{s} frameborder=\"0\" allowfullscreen]"
            else
              dst += "<iframe src=\"#{attributes['src']}\"#{s} frameborder=\"0\" allowfullscreen></iframe>"
            end
          elsif command == "image"
            s = attributes.map { |key, value| (key == 'src' || key == 'selflink' || (key == 'style' && attributes.has_key?('caption'))) ? '' : " #{key}=\"#{value}\"" }.join
            # TODO, if src is not relative, don't prefix it

            if attributes.has_key?('caption')
              # if !attributes.has_key?('width')
                # raise 'caption, but no width!'
              # end
              dst += "<div style=\"#{attributes['style']}\">"
            end

            path = attributes['src']
            if path !~ /^https?:\/\//
              path = "#{@root}/#{path}"
            end

            is_selflink = attributes.has_key?('selflink') && attributes['selflink'] == 'true'
            if is_selflink
              dst += "<a href=\"#{path}\">"
            end
            dst += "<img src=\"#{path}\"#{s}>"
            if is_selflink
              dst += "</a>"
            end

            if attributes.has_key? 'caption'
              dst += "<br><i><small>" + attributes['caption'] + "</small></i></span>"
              dst += "</div>"
            end
          else
            pair_string = attributes.map { |key, value| " #{key}=\"#{value}\"" }.join

            if command != 'code' || !attributes.has_key?('file')
              if @tokens[@i].type == :EOL
                @i += 1
              else
                raise "expected EOL, found #{@tokens[@i].type}"
              end
            end

            if command == 'code'
              if attributes.has_key?('hide')
                dst += "<div class=\"indented\">"
                dst += "<a href=\"#\" class=\"toggler\">#{attributes['hide']}</a>"
                dst += '<div class="togglee">'
              end

              code = ''
              if attributes.has_key? 'file'
                code = IO.read(attributes['file'])
              else
                while @i < @tokens.length && (@tokens[@i].type == :CODE || @tokens[@i].type == :EOL)
                  if @tokens[@i].type == :CODE
                    if @i + 2 < @tokens.length && @tokens[@i + 2].type == :CODE
                      code += "#{@tokens[@i].text}\n"
                    else
                      code += @tokens[@i].text
                    end
                    @i += 1
                  else
                    code += "\n\n"
                  end
                  if @tokens[@i].type == :EOL
                    @i += 1
                  else
                    raise "expected EOL after code, found #{@tokens[@i].type}"
                  end
                end
              end

              if attributes.has_key?('scrambled')
                dst += '<div class="scramblebox">'
                dst += '<ol class="scrambled">'
                code.lines.each do |line|
                  if attributes.has_key? 'lang'
                    dst += '<li>'
                    IO.popen("coderay -#{attributes['lang']} -div", 'r+') do |pipe|
                      pipe.puts line.chomp
                      pipe.close_write
                      code = pipe.read
                      dst += code.chomp
                    end
                    dst += '</li>'
                  else
                    dst += "<li><pre>#{line.chomp}</pre></li>"
                  end
                end
                dst += '</ol>'
                dst += '<input type="button" class="scramble" value="Scramble">'
                dst += '</div>'
              else
                if attributes.has_key? 'lang'
                  IO.popen("coderay -#{attributes['lang']} -div", 'r+') do |pipe|
                    pipe.puts code
                    pipe.close_write
                    code = pipe.read
                    dst += "<div#{pair_string}>#{code}</div>"
                  end
                else
                  dst += "<pre#{pair_string}>"
                  dst += entitize(code)
                  dst += '</pre>'
                end
              end

              if attributes.has_key?('hide')
                dst += '</div>'
                dst += '</div>'
              end

            elsif command == 'latex'
              ['id'].each do |key|
                if !attributes.has_key? key
                  raise "latex snippet must have #{key} attribute!"
                end
              end

              latex_source = <<'EOF'
\documentclass[fleqn]{article}
\usepackage{mathtools}
\usepackage{amsmath}
\usepackage[active,tightpage,textmath,displaymath,pdftex]{preview}
\begin{document}
\makeatletter\setlength\@mathmargin{0pt}\makeatother
EOF
              while @i < @tokens.length && @tokens[@i].type == :CODE
                latex_source += @tokens[@i].text
                @i += 1

                if @tokens[@i].type == :EOL
                  @i += 1
                else
                  raise "expected EOL after latex, found #{@tokens[@i].type}"
                end
              end
              latex_source += "\n\\end{document}"

              # IO.popen("pdflatex -jobname=#{attributes['id']} && gs -sDEVICE=png16m -dTextAlphaBits=4 -r144 -dGraphicsAlphaBits=4 -dSAFER -q -dNOPAUSE -dBATCH -sOutputFile=#{attributes['id']}.png #{attributes['id']}.pdf && mogrify -quality 100 -resize #{attributes['width']}x#{attributes['height']} #{attributes['id']}.png", 'w+') do |pipe|
              IO.popen("pdflatex -jobname=#{attributes['id']} && (pdftoppm -rx 400 -ry 400 -png #{attributes['id']}.pdf > #{attributes['id']}.png)", 'w+') do |pipe|
                pipe.write(latex_source)
                pipe.close_write
                pipe.read.split("\n").each do |line|
                  STDERR.puts line
                end
              end

              dst += "<img src=\"#{@root}/#{attributes['id']}.png\"#{s} style=\"#{@styles['latex_math']}\">"

            elsif command == 'lineveil'
              dst += "<pre#{pair_string}>"
              li = 0
              while @i < @tokens.length && @tokens[@i].type == :CODE
                dst += "<a href=\"#\" class=\"lineveil\">#{li}</a>: <span class=\"lineveil\">#{@tokens[@i].text}</span>"
                if @i + 2 < @tokens.length && @tokens[@i + 2].type == :CODE
                  dst += "\n"
                end
                @i += 1
                if @tokens[@i].type == :EOL
                  @i += 1
                else
                  raise "expected EOL after code, found #{@tokens[@i].type}"
                end
                li += 1
              end
              dst += '</pre>'
            elsif command == 'madeup'
              ['id', 'width', 'height'].each do |key|
                if !attributes.has_key? key
                  raise "madeup snippet must have #{key} attribute!"
                end
              end

              code = ''
              while @i < @tokens.length && (@tokens[@i].type != :RIGHT_BRACKET) # || (@tokens[@i].type == :EOL && @i + 1 < @tokens.length && @tokens[@i + 1] !)
                code += @tokens[@i].text
                # if @i + 2 < @tokens.length && @tokens[@i + 2].type == :CODE
                  # code += "\n"
                # end
                @i += 1
                # if @tokens[@i].type == :EOL
                  # @i += 1
                # else
                  # raise "expected EOL after code, found #{@tokens[@i].type}"
                # end
              end

              if @target == 'wordpress'
                dst += <<EOF
<pre>[mup id=#{attributes['id']} width=#{attributes['width']} height=#{attributes['height']} frameborder="0"]#{code}[/mup]</pre>
EOF
              else
                dst += <<EOF
<div id="mup_#{attributes['id']}">
  <form style="display: none" id="mup_form_#{attributes['id']}" target="mup_frame_#{attributes['id']}" action="http://embed.madeup.xyz" method="post">
    <textarea name="src">#{code}</textarea>
    <input type="submit"/>
  </form>
  <iframe name=\"mup_frame_#{attributes['id']}\" src=\"\" width=\"#{attributes['width']}\" height=\"#{attributes['height']}\" frameborder=\"0\"></iframe>
  <script>                                                                                                                                                                        
    document.getElementById('mup_form_#{attributes['id']}').submit();
  </script>
</div>
EOF
              end

            elsif command == 'quote'
              dst += "<blockquote#{pair_string}>"
              while @i < @tokens.length && (first_of_content? @tokens[@i].type)
                dst += content
                dst += "\n" if @i + 1 < @tokens.length && @tokens[@i + 1].type != :RIGHT_BRACKET
                if @tokens[@i].type == :EOL
                  @i += 1
                else
                  raise "expected EOL after quote content, found #{@tokens[@i].type}"
                end
              end
              dst += '</blockquote>'
            elsif command == 'haiku'
              dst += "<blockquote#{pair_string}>"
              is_first = true
              while @i < @tokens.length && (first_of_content? @tokens[@i].type)
                if !is_first
                  dst += '<br>'
                else
                  is_first = false
                end
                dst += content
                dst += "\n" if @i + 1 < @tokens.length && @tokens[@i + 1].type != :RIGHT_BRACKET
                if @tokens[@i].type == :EOL
                  @i += 1
                else
                  raise "expected EOL after quote content, found #{@tokens[@i].type}"
                end
              end
              dst += '</blockquote>'
            elsif command == 'block'
              if attributes.has_key?('hide')
                dst += "<div class=\"indented\">"
                dst += "<a href=\"#\" class=\"toggler\">#{attributes['hide']}</a>"
                if attributes.has_key?('class')
                  attributes['class'].gsub!(/"?$/, ' togglee')
                else
                  attributes['class'] = 'togglee'
                end
              end

              pair_string = attributes.map { |key, value| " #{key}=\"#{value}\"" }.join

              dst += "<div#{pair_string}>\n"
              while @i < @tokens.length && (first_of_line? @tokens[@i].type)
                dst += line
              end
              dst += '</div>'

              if attributes.has_key?('hide')
                dst += '</div>'
              end
            elsif command == 'strike'
              dst += '<strike>'
              while @i < @tokens.length && (first_of_line? @tokens[@i].type)
                dst += line
              end
              dst += '</strike>'
            elsif command == 'toggle'
              dst += "<div class=\"toggle\"#{pair_string}>"
              while @i < @tokens.length && (first_of_content? @tokens[@i].type)
                dst += content
                dst += "\n" if @i + 1 < @tokens.length && @tokens[@i + 1].type != :RIGHT_BRACKET
                if @tokens[@i].type == :EOL
                  @i += 1
                else
                  raise "expected EOL after toggle content, found #{@tokens[@i].type}"
                end
              end
              dst += '</div>'
            end
          end
        else
          raise 'expected ID'
        end

        if @tokens[@i].type == :RIGHT_BRACKET
          @i += 1

          # TODO
          # if @tokens[@i - 2].type == :COMMENT && @i < @tokens.length && @tokens[@i].type == :EOL
            # @i += 1
          # end
        else
          puts dst
          raise "expected ], found #{@tokens[@i].inspect}"
        end
      end
    end

    dst += "</p>" if needs_paragraph

    dst
  end
end

# TODO
# comments - check
# linebreaks - check
# nesting - check
# attributes - check
# unordered lists - check
# ordered lists - check
# bold text - check
# nested lists - check
# links - check
# images - check
# coderay - check
# toggle - check
# lineveil - check
# madeup iframe - check
# general iframe - check

# src = <<EOF
# [lineveil
# a
# b
# c
# d
# ]

# [frame src=http://www.twodee.org width=600 height=200]

# [madeup width=600 height=400 id=square
# moveto 0, 0, 0
# repeat 4
  # move 10
  # yaw 90
# end
# dowel
# ]
# EOF

# src = <<EOF
# - [toggle
# [code
# this quick brown fox
# ]
# ]
# - [toggle
# that quick brown fox
# ]
# - [toggle
# there quick brown fox
# ]
# EOF

# src = <<'EOF'
# - [code
# line 1
# ]
# - [code 
# line 2
# ]

# [code lang=madeup
# moveto 0, 0, 0
# repeat 4
  # move 10
  # yaw 90
# end
# ]

# [code lang=c
# int main(int argc, char **argv) {
  # printf("%d\n", argc);
# }
# ]
# EOF

# src = <<EOF
# - a
# - b
  # 1. **zoo**
    # - the
    # - inner
    # - inner
    # - list
  # 2. *2*
  # 3. `some program code`
# - c

# asdfasd [link to="http://www.madeup.xyz" title="Zig Zog"]
# [image src=foo.png width=20 height=40]
# EOF

# src = <<EOF
# 1. foo0
# 2. foo1
# 3. foo2
# 4. foo3

# Hi
## There
### Agenda
#### Four
##### Five
###### Six

# - dog
# - cat
# - whistle

# foo `*code*` is a winner
# [" this is a comment]

# [code lang=ruby
# puts 10
# ]

# [block id=foo7 width=20
# 123
# [block
# inside block
# ]
# ]
# EOF

src = File.read(path)
lexer = Lexer.new src
lexer.lex
parser = Parser.new lexer.tokens, target
puts parser.parse
